<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> nodejs概览 · hammer's blog</title><meta name="description" content="nodejs概览 - hammer"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="hammer's blog"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">nodejs概览</h1><div class="post-info">Jun 12, 2017</div><div class="post-content"><h2 id="nodejs特点"><a href="#nodejs特点" class="headerlink" title="nodejs特点"></a>nodejs特点</h2><p>node.js 特点是异步式I/O，I/O是指涉及磁盘读写，网络通信、数据库读写等任何涉及计算机存储结构的输入输出等操作。适用情景是处理高并发、轻计算的业务情景，比如网络聊天，因为它是单线程的处理过程，系统的计算能力有限，我猜可能是因为cpu把很多资源配置在了事件驱动的这个机制中来实现异步I/O。以后可以考虑用goLang来处理这种复杂计算网络业务。<br> <a id="more"></a></p>
<h2 id="node-js的回调函数与事件"><a href="#node-js的回调函数与事件" class="headerlink" title="node.js的回调函数与事件:"></a>node.js的回调函数与事件:</h2><p>初步涉及到文件读取模块（fs）与事件模块(events),文件读取模块又分为异步与同步（sync),异步的readFile()有三个参数，文件路径,文件格式，回调函数，其中回调函数有2个默认参数，第一个是抛出的异常err,另一个是返回的数据结果data。同步的readFile（）没有第三个参数即回调函数，函数执行后返回读取的数据结果。事件模块涉及到获取事件对象，注册事件，触发事件。获取事件发射器对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter=<span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter；</span><br></pre></td></tr></table></figure></p>
<p>tips:1.require events not event,get EventEmitter instead of eventEmitter and it’s a property.<br>2.when create a object ,the first letter of variable is supposed to uppercase.<br>3.eventObject.on(eventName,callback)<br>4.to trigger event is use event.emit(eventName).</p>
<h2 id="原生模块与文件模块："><a href="#原生模块与文件模块：" class="headerlink" title="原生模块与文件模块："></a>原生模块与文件模块：</h2><p>node.js中的模块分为两种，一种是原生模块，包括http,fs，event等，还有一种文件模块，通常就是一个js文件（.js)，或者一些c++/c编译后的一个扩展（.node）,还有json后缀的文件。node会根据不同的后缀名对执行不同的加载机制。关于node编译这些文件模块时，特别是js的文件模块时，它会将模块包裹到一个匿名自执行函数中，这个函数带有require,exports,module等参数，这是我们在某个js文件中可直接调用require的原因。</p>
<p>Node.js的模块分为两类，一类为原生模块，一类为文件模块。原生模块在Node,js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。其中原生模块都被定义在lib这个目录下面，文件模块则不定性。</p>
<p>由于通过命令行加载启动的文件几乎都为文件模块。我们从Node.js如何加载文件模块开始谈起，加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。</p>
<h2 id="CommonJS规范是什么？"><a href="#CommonJS规范是什么？" class="headerlink" title="CommonJS规范是什么？"></a>CommonJS规范是什么？</h2><p>我们知道像java有引入类或者包这样的依赖机制，像c或c++也有类似的引入机制，就算在js中也有引入各种工具库如jquery这样的概念，CommonJS就是对于引入这种依赖文件的一种规范、标准，因为js是一门很自由的函数式编程语言，没有相关规范的话，在工程中的榫接是会有问题的，不利于工程化。Node.js是这种规范的实现，包括它当中的原生模块机制或者文件模块格式等都是遵循CommonJS标准的，CommonJS规范里具体包括以下内容：</p>
<p>1.Modules</p>
<p>2.Binary strings and buffers</p>
<p>3.Charset encoding</p>
<p>4.Binary,buffered,and textual input and output(io) streams</p>
<p>5.System process argument,environment,and streams</p>
<p>6.File System interface</p>
<p>7.Socket streams</p>
<p>8.Unit test assertions,running,and reporting</p>
<p>9.Web server gateway interface,JSGI</p>
<p>10.Local and remote packages and package management</p>
<p>CommonJS在浏览器中不能直接应用，一般需要用browserify来打包使浏览器拥有相关能力，相当于个变量引入的配置问题。像实现了CommonJS的node.js为什么会更适用于服务器端，是因为多数时候我们的文件都是在本地的，而在浏览器中我们是要通过http等请求从服务器端拉取文件的。而AMD是require.js在其发展过程中推广的一种非服务器端的规范，它使人们在浏览器中也能良好的运用js的包依赖机制，一开始它倾向于前置依赖，即事先把所有依赖先写出来。CMD是sea.js在其发展中推广的另一张规范，它特点是就近依赖。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/07/06/flex基本用法/" class="prev">PREV</a><a href="/2017/06/12/前端工程化初识/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://yoursite.com">hammer</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>