<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hammer&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-08T13:44:33.970Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hammer</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js数组去重方法与常用API</title>
    <link href="http://yoursite.com/2018/02/19/js%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%96%B9%E6%B3%95%E4%B8%8E%E5%B8%B8%E7%94%A8API/"/>
    <id>http://yoursite.com/2018/02/19/js数组去重方法与常用API/</id>
    <published>2018-02-19T14:23:13.000Z</published>
    <updated>2018-03-08T13:44:33.970Z</updated>
    
    <content type="html"><![CDATA[<p>数组时最常用的数据结构之一，所谓千里之行，始于足下，让我从数组开始重新学吧。<br><a id="more"></a></p><p>##方法一：排完序再去重<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;);</span><br><span class="line">       <span class="built_in">console</span>.log(arr)</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">removeRepeat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]==arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">                arr.splice(i,<span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">console</span>.log(arr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    removeRepeat();</span><br></pre></td></tr></table></figure></p><p>##方法二：push<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> newArr=[];</span><br><span class="line">newArr.push(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;newArr.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;newArr.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(newArr[j]!=arr[i])&#123;</span><br><span class="line">newArr.push(arr[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##方法三：Hash<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="string">'str'</span>,<span class="number">100</span>,<span class="string">'ss'</span>,<span class="number">50</span>,<span class="number">15</span>,<span class="number">1</span>,<span class="number">15</span>,<span class="number">50</span>,<span class="string">'str'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeRepeat</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// arr.sort(function(a,b)&#123;return a-b&#125;);</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]==arr[i+<span class="number">1</span>])&#123;</span><br><span class="line">            arr.splice(i,<span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr)</span><br><span class="line">&#125;</span><br><span class="line">removeRepeat(arr);</span><br><span class="line"></span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushUnique</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newArr=[];</span><br><span class="line">    newArr.push(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;newArr.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(newArr[j]==arr[i])&#123;</span><br><span class="line">                flag=!flag;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">            newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    newArr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;); </span><br><span class="line">    <span class="built_in">console</span>.log(newArr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pushUnique(arr)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useHash</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash=&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> temp=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hash[arr[i]])&#123;</span><br><span class="line">            hash[arr[i]]=<span class="literal">true</span>;</span><br><span class="line">            temp.push[arr[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">useHash(arr);</span><br></pre></td></tr></table></figure></p><p>Array.forEach(function callback(currentValue,index,arry){     }[，thisArg])<br>不返回新数组，也无返回值，返回undefined.<br>兼容性：IE9<br>适用场景：现代浏览器中对原始数组数据的序列化操作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val,index</span>)</span>&#123;</span><br><span class="line">             val*=<span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'index:'</span>+index,<span class="string">'value:'</span>+val)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">index:<span class="number">0</span> value:<span class="number">2</span></span><br><span class="line">index:<span class="number">1</span> value:<span class="number">6</span></span><br><span class="line">index:<span class="number">2</span> value:<span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>在回调函数执行过程中，若有对原数组的添加操作如push，它不会被访问到.但若有对原数组的删除操作却会被即时刷新与访问到。对原有范围内数据的操作会即时刷新。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">       arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">val,index,arr</span>)</span>&#123;</span><br><span class="line">             arr[index+<span class="number">1</span>]=<span class="number">100</span>;</span><br><span class="line"> arr.push(<span class="number">1000</span>)</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'index:'</span>+index,<span class="string">'value:'</span>+val)</span><br><span class="line">       &#125;)</span><br><span class="line">       <span class="built_in">console</span>.log(arr)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//output</span></span><br><span class="line">index:<span class="number">0</span> value:<span class="number">1</span></span><br><span class="line">index:<span class="number">1</span> value:<span class="number">100</span></span><br><span class="line">index:<span class="number">2</span> value:<span class="number">100</span></span><br><span class="line">          [<span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">1000</span>]</span><br></pre></td></tr></table></figure></p><p>Array.prototype.map(function callback(currentValue,index,array){}[ ,thisArg] )<br>返回一个新数组，这是与forEach的主要区别。<br>callback函数中需要返回值currentValue<br>兼容性：IE9<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line">         <span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">current,index,arr</span>)</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> current/<span class="number">2</span></span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="built_in">console</span>.log(arr)</span><br><span class="line">         <span class="built_in">console</span>.log(newArr)</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">0.5</span>,<span class="number">1.5</span>,<span class="number">2.5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">          <span class="keyword">var</span> newArr = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">val,index,arr</span>)</span>&#123;</span><br><span class="line">                arr[index+<span class="number">1</span>]=<span class="number">100</span>;</span><br><span class="line">                arr.push(<span class="number">1000</span>)</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'index:'</span>+index,<span class="string">'value:'</span>+val)</span><br><span class="line">                <span class="keyword">return</span> val</span><br><span class="line">         &#125;)</span><br><span class="line">         <span class="built_in">console</span>.log(arr)</span><br><span class="line">         <span class="built_in">console</span>.log(newArr)</span><br><span class="line">   <span class="comment">//output</span></span><br><span class="line">   index:<span class="number">0</span> value:<span class="number">1</span></span><br><span class="line">         index:<span class="number">1</span> value:<span class="number">100</span></span><br><span class="line">    index:<span class="number">2</span> value:<span class="number">100</span></span><br><span class="line">           [<span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">1000</span>]</span><br><span class="line">    [<span class="number">1</span>, <span class="number">100</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure></p><p>Array.prototype.every(function callback(currentValue,index,array){}[ ,[thisArg])<br>整个函数返回boolean值，ture或者false<br>callback函数中需返回true或false<br>兼容性：IE9<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> test = [<span class="string">'1'</span>,<span class="number">5</span>,<span class="string">'2'</span>,<span class="number">4</span>,<span class="string">'3'</span>];</span><br><span class="line">        <span class="keyword">var</span> result = test.every(<span class="function"><span class="keyword">function</span>(<span class="params">cur,index,arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cur=<span class="built_in">parseInt</span>(cur);</span><br><span class="line">            <span class="keyword">return</span> (cur&gt;<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">  <span class="comment">//output</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.some(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue,index,array</span>)</span>&#123;&#125;[ ,thisArg])</span><br><span class="line">  整个函数返回一个boolean值</span><br><span class="line">  callback中需返回一个boolean值。</span><br><span class="line">  兼容性：IE9</span><br><span class="line">      <span class="keyword">var</span> test = [<span class="string">'1'</span>,<span class="number">5</span>,<span class="string">'2'</span>,<span class="number">4</span>,<span class="string">'3'</span>];</span><br><span class="line">         <span class="keyword">var</span> result = test.some(<span class="function"><span class="keyword">function</span>(<span class="params">cur,index,arr</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">var</span> cur=<span class="built_in">parseInt</span>(cur);</span><br><span class="line">            <span class="keyword">return</span> (cur&gt;<span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        <span class="comment">//output</span></span><br><span class="line">   <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>$.each(function(index,eleDom){})<br>遍历jquery对象集合，为每个匹配元素执行一个函数。<br>与之前几个数组方法不同的地方，一是它是jquery对象才有的方法，其次回调函数只有2个参数，一个是当前索引，一个是当前dom元素。而且函数中this总是指向当前dom元素。</p><p>$.map(function(index,eleDom){})<br>通过一个函数匹配当前集合中的每个元素，并返回一个新的jquery对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组时最常用的数据结构之一，所谓千里之行，始于足下，让我从数组开始重新学吧。&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>webpack4新特性与坑点</title>
    <link href="http://yoursite.com/2018/02/09/webpack4%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2018/02/09/webpack4新特性/</id>
    <published>2018-02-09T03:25:43.000Z</published>
    <updated>2018-03-08T14:04:46.223Z</updated>
    
    <content type="html"><![CDATA[<p>##快速搭建方案</p><p> webpack4与前几个版本的一个重要区别是，现在它有快速搭建模式，这个模式简化了在小型项目或demo中让人诟病的复杂配置模式，这意味着现在你不需要那个webpack.config.js也能快速的来使用webpack了。只要以下几个步骤：</p> <a id="more"></a><ol><li><p>新建一个webpack4-quickstart目录并进入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack4-quickstart &amp;&amp; cd webpack4-quickstart</span><br></pre></td></tr></table></figure></li><li><p>初始化package.json</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn init -y</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>为本地项目安装webpack与webpack-cli</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure></li><li><p>新建一个src文件，里面新建一个index.js（作为webpack4快速模式默认的入口）</p></li><li><p>在package.json中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack --mode development&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;webpack --mode production&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在cmd中运行 npm run dev或者npm run build</p></li></ol><p>这样一个无需配置文件的webpack项目便搭建成功了，它默认入口是\src\index.js,默认的输出文件是\dist\main.js</p><h2 id="生产环境模式与开发环境模式"><a href="#生产环境模式与开发环境模式" class="headerlink" title="生产环境模式与开发环境模式"></a>生产环境模式与开发环境模式</h2><p>在快速搭建模式中如果缺少了第五步，那么cmd中就会提示一个警告信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING in configuration</span><br><span class="line">The &apos;mode&apos; option has not been set. Set &apos;mode&apos; option to &apos;development&apos; or</span><br><span class="line">&apos;production&apos; to enable defaults for this environment</span><br></pre></td></tr></table></figure></p><p>在webpack4中，新增了mode模式的写法，指明打包是开发环境还是生产环境，二者的区别是开发环境中的打包出来的代码不经过UglifyJs的压缩，不产生source map,而生产环境模式打包出来的代码经过过压缩，作用域提升，tree-shaking等优化。</p><p>##其余新特性</p><ul><li>大量针对打包速度与性能的优化，包括更健壮的默认配置，官方公布报告显示，打包性能有60%以上的提升。</li><li>对多页面应用中常用的CommonsChunkPlugin被替换为optimize.splitChunks和optimization.runtimeChunk，让开发者更简单实现公共代码提取与代码分割。</li><li>支持WebAssembly与CommonJS,AMD,ESM等模块系统。</li></ul><p>##兼容问题</p><p>目前许多第三方的plugin与loader未对webpack4做好兼容措施，包括日常中经常使用到的HtmlWebpackPlugin，为此webpack团队专门为它做了个兼容方案。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">yarn add html-webpack-plugin@webpack-contrib/html-webpack-plugin</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/webpack/webpack/releases/tag/v4.0.0" target="_blank" rel="noopener">github-webpack</a></li><li><a href="http://mp.weixin.qq.com/s/jNKuUyqxoI25r-J1RpT7wA" target="_blank" rel="noopener">前端之巅-wbaock4正式发布，实现零配置启动</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##快速搭建方案&lt;/p&gt;
&lt;p&gt; webpack4与前几个版本的一个重要区别是，现在它有快速搭建模式，这个模式简化了在小型项目或demo中让人诟病的复杂配置模式，这意味着现在你不需要那个webpack.config.js也能快速的来使用webpack了。只要以下几个步骤：&lt;/p&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>js中的匿名函数</title>
    <link href="http://yoursite.com/2018/01/06/js%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/01/06/js中的匿名函数/</id>
    <published>2018-01-06T13:45:22.000Z</published>
    <updated>2018-03-08T13:43:41.518Z</updated>
    
    <content type="html"><![CDATA[<p>##线索</p><p>今天在看webpack打包成的bundle.js时发现这种写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;()</span><br></pre></td></tr></table></figure></p><p>之前在一些流行的js插件库中也见过同样的写法，只是隐约知道是一种匿名的立即执行函数，但具体作用原理并不是特别理解，于是上网找了些资料，试图尽量明白其作用原理。<br><a id="more"></a></p><p>##变量声明与表达式</p><p>###声明</p><p>多数编程语言中，变量都得声明后方可调用。常见的变量声明如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">const</span> a;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &lt;!--TODO--&gt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span>()</span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(height, width) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Bar'</span>;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>当然es2015中还有一些新的声明方式，诸如function</em>,async function等*</p><p>但js作用一门“灵活的”语言，它的声明规则有一些区别于其他语言的quirk。比如它有一个声明提升（Hoisting）的默认规则。这意味着以下代码并不会出现“变量未声明”这种报错。</p>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  environment:window7 chrome62</span><br><span class="line">  &gt;&gt;<span class="literal">undefined</span></span><br><span class="line">  &gt;&gt;ƒ b()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  语法解释器会在解析代码前，将所有通过var关键字声明的变量预先提取，可以理解为这时候的代码变更为如下顺序<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) </span><br><span class="line"><span class="built_in">console</span>.log(b) </span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  如果变量a与函数名同名，此时函数的优先级更高。</p><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p> 表达式与声明不一样的地方在于，表达式是由运算符构成，并能产生运算结果，例子如下：<br>   <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line">b()</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  environment:window7 chrome62</span><br><span class="line">  &gt;&gt;<span class="literal">undefined</span></span><br><span class="line">  &gt;&gt;<span class="literal">undefined</span></span><br><span class="line">  &gt;&gt;Uncaught <span class="built_in">TypeError</span>: funcName is not a <span class="function"><span class="keyword">function</span></span></span><br></pre></td></tr></table></figure></p><p> 如果给普通的声明前面加上赋值符号，就形成了一个表达式。在声明提升的过程中只提升变量的声明，并不会对变量的赋值运算做提升。只有代码执行到表达式这行时才进行赋值操作。这也就不难解释上述a与b的输出均为undefined。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>  要回答本文开头的那个疑惑，不得不提匿名函数。顾名思义，匿名函数就是没有函数名的函数。<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is an anonymous function'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>既然是匿名的，那么该如何去调用它呢？一种方式是将匿名函数赋值给一个变量后再调用，另一种方式即通过自执行函数。常见的几种匿名自执行函数写法如下：</p><ul><li>( function(){}() )</li><li>( function(){} )()</li><li>! funcion(){}()</li><li>+function(){}()</li><li>var foo = function(){}()</li></ul><p>有时候我会将匿名函数写成这种形式，<strong><em>“ function(){}() ”</em></strong> 然后发现浏览器就会报错，那么为什么上面几个加了（）,！, +的就不会报错呢，根本原因是这几个运算符改变了解析器对代码的语法分析，将语句变为表达式，而表达式后面加括号该表达式会立即执行。前文说过声明语句与表达式的区别就是后者由运算符构成，并能产生一个值。所以不单是+，！，（），前面加上别的合法运算符如++，–，~等都可以让解析器成功解析成立即自执行函数。这里面的合法意味着不能加*，&amp;&amp;，/等，因为这些是二元运算符，需要两个运算对象。</p><p>##为什么使用匿名函数</p><p>问题是哪些情况下适合用匿名自执行函数呢?</p><ul><li>当我们不希望自己代码的变量污染全局变量时使用匿名自执行函数就是一种很好的策略。所以很多js模块都会使用匿名立即自执行函数的形式以避免自己的变量与其余js模块的命名冲突。</li><li>当我们希望某个变量存储的值不是函数本身而是函数返回值时。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##线索&lt;/p&gt;
&lt;p&gt;今天在看webpack打包成的bundle.js时发现这种写法&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;之前在一些流行的js插件库中也见过同样的写法，只是隐约知道是一种匿名的立即执行函数，但具体作用原理并不是特别理解，于是上网找了些资料，试图尽量明白其作用原理。&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>从浏览器地址栏输入一串url到页面呈现这个过程中发生了什么？</title>
    <link href="http://yoursite.com/2017/12/23/%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%B2url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/12/23/从浏览器地址栏输入一串url到页面呈现这个过程中发生了什么？/</id>
    <published>2017-12-23T15:43:12.000Z</published>
    <updated>2018-03-08T13:43:35.315Z</updated>
    
    <content type="html"><![CDATA[<p>##线索</p><p>从浏览器地址栏输入一串url到页面呈现这个过程中发生了什么？在很多场合看见过这个问题，但一般也就大概浏览一下，自己并没有去深入研究一番，最近有空便研究了下，网上当然也有很多类似的分析，而且有些甚至涉及到物理层的底层硬件相关，虽然自己本科专业是电子信息专业，但只是懂个轮廓，很多细节还是不太清楚，所以自己的笔记目前就只囊括在非物理层的描述。<br><a id="more"></a></p><p>##URL</p><p>URL(universal resource locator)的中文译名是统一资源定位符，可以理解为一个用于标识资源地址的符号,它的发明者即被称为“互联网之父”的Tim Berners-Lee，最近刚获得2016年的图灵奖。一个标准的url由协议名，服务器，端口号，文件路径，查询字符组成:<br>protocol :// hostname[:port] / path / parameters?query#fragment<br>在大多数浏览器中，我们可以省略协议名或者端口号，因为几乎所有网页内容都是基于http或https的，然后端口也是默认的80。<br>比如我博客的url是：<br>“h ttp://ahammer.science/2017/03/19/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96-%E5%88%9D%E8%AF%86/“<br>这里面省略了端口号与查询字符，至于末尾一连串的%开头的字符则是因为浏览器不能直接识别含有中文的文件路径而做的编码处理。<br>当我们在浏览器地址栏中输入的url不规范时，比如直接是中文，或者协议名，主机名不规范时，通常浏览器会将该输入传给默认的搜索引擎并返回相应的搜索结果，还有种情况，有些网站我们不输入协议名与www而只输入部分字符现代浏览器都会自动补全可能的完整的网站路径，如输入’ba’，chrome浏览器中这会直接补全w ww.baidu.com，这是因为浏览器内核会根据我们的历史输入做智能判断，从而提高我们的网络浏览体验。</p><p>##HSTS</p><p>按下Enter键后，浏览器一般会检查<a href="https://zh.wikipedia.org/wiki/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">HSTS</a>列表,HSTS(Http Strict Transport Security)的作用是强制客户端与服务器端使用https协议连接，防止黑客的SSL剥离攻击，但这个策略机制的一个缺点是不能在首次访问某个网站时触发，而通过浏览器预置的HSTS列表就能应对这一缺陷，HSTS列表检测完毕后，浏览器会先在浏览器缓存中查看是否已经有该域名信息，如果没有的话就会调用gethostbyname()方法（不同的操作系统调用的方法不同）去查询系统中是否有缓存信息，如果系统缓存中也没有相关记录，那么该url就会被发送给DNS服务器，为什么要发送给DNS服务器呢？</p><p>##DNS</p><p>DNS即域名解析系统的作用是将我们输入的url解析为ip地址，为了便于理解与记忆，一般url是用中英文字符表示，但计算机更懂得是机器语言（二进制表示，代表高低电平的0与1）所以每个url都有与之对应的ip地址，一个url可能对应多个ip地址，这又涉及到DNS负载均衡等问题。<br>以下是两个ip地址实例：</p><ul><li>192.168.55.60（本机在本地局域网的ip地址）</li><li>111.13.101.208（本机ping <a href="https://www.baidu.com得到的ip地址）" target="_blank" rel="noopener">https://www.baidu.com得到的ip地址）</a><br>可以发现这两个ip地址并不是二进制表示的，很显然用二进制表示的话会很长，比如上面百度ip地址的二进制表示是1101111000011010110010111010000，非常不方便我们输入与记忆，尽管最终电脑还是得转换为二进制去理解它们。<br>在发送给DNS服务器之前，我们需要知道DNS服务器或默认网关的IP地址，这些工作由ARP（域名解析协议）配合网关，MAC等完成。在得到DNS服务器地址后，通常使用UDP协议发送请求包给DNS服务器进行递归查询，DNS服务器分为根域名服务器，顶级域名服务器（.com/.cn/.org等），及本地域名服务器，查询的过程由根域名一直递归到本地域名服务器，比如百度域名的解析过程是：</li></ul><p>step1: .com<br>step2: baidu.com.<br>step3: w w w.baidu.com.<br>具体过程可以参考<a href="https://www.zhihu.com/question/23042131" target="_blank" rel="noopener">DNS解析过程详解</a></p><p>##建立TCP连接</p><p>当DNS服务器返回请求URL对应的IP地址后，这时候就轮到socket（一种由操作系统提供的网络上进程间的通信机制）出场了，作为对TCP/IP协议的封装，socket会发出一个TCP协议的数据流，数据流接着在传输层被加入目标端口继而封装成TCP segment，然后该报文被发送至网络层,网络层会在其中加入本机与目标服务器的ip地址，这时候就变成TCP packet进入链路层，链路层中会为其加入frame头部，里面包含里本机的MAC地址以及网关的MAC地址，最后这个TCP封包就会经由无线或有线网络发送到目标服务器，其中涉及到的网络寻址与路由分发等不在此详表，在浏览器与目标服务器的TCP连接建立后，浏览器就会通过它来发送http请求。<br>在建立TCP连接的过程中客户端与服务器端会发生‘三次握手’，过程如下：</p><p><em>三次握手</em><br><img src="http://oupe487b3.bkt.clouddn.com/tcpopen3way.png" alt="三次握手"><br>首先由客户端发送SYN=1标志位与seq=x（x为随机数字，作为该报文的检验数据）的报文到服务器端，此时客户端进入SYN-SENT的状态，服务器端接受到后将返回标志位SYN=1与标志位ACK=1的的报文，并附上确认报文ack=x+1与该报文的seq=y（y同为随机数字，作为该报文的检验数据），此时服务器端的状态是SYN-RECEIVED，当客户端收到该报文时会返回标志位ACK=1与ack=y+1用来表示已正确收到这报文，此时客户端的状态为ESTABLIDHED，当服务器端也接受到时状态也变为ESTABLISHED.<br>TCP三次握手目的是为了防止已失效的连接请求报文段突然又传输到服务端，因而产生错误，本质上这是在不可靠信道上进行可靠传输的最少的通信次数。就像我们打电话，甲说：你好，听到了吗？乙回：我听到了，你听到了吗？甲回：我也听到了。需要经过至少三次的会话才可以确保双方都知道目前通信是可靠的。</p><p>##HTTP请求</p><p>TCP连接建立后，就可以发送http请求了，http请求由四个部分组成：</p><ul><li>请求行(request line)，用来说明请求类型（get/post等），要访问的资源URI路径，http版本号等。</li><li>请求头部(request header)，缓冲相关控制，客户端代理信息等。</li><li>空行(empty line),起标志作用的空行。</li><li>请求数据(request data)，客户端发给服务端的请求数据，这部分数据并不是每个请求必须的。</li></ul><p>HTTP作为应用层的协议，具体作用就是传输文本、图像以及在浏览器与服务器间传输的其他类型文件（比如css、js文件等），浏览器成功发送http请求并得到服务器端的响应，成功接收各种请求资源时，就由浏览器开始渲染工作，但值得注意的时，在现代浏览器中，这个过程不是单线程的，浏览器可以边接收服务器端的资源，边解析与渲染html文件。</p><p>##关键渲染路径-Critial Rendering Path</p><p>从获取HTML文件直到浏览器以像素点的方式在屏幕中绘制出页面的内容确实经历了很多步骤，这些步骤我们称之为关键渲染路径。优化前端页面的加载与渲染，都可以从关键路径渲染中入手。以下是CRP过程中主要的6个步骤：</p><ul><li>构建文档对象模型（DOM tree）</li><li>构建css对象模型（CSSOM)</li><li>完成1阶段后的时间节点叫Domcontentloaded,许多js框架都会在此刻运行js，比如jq，所以这阶段也可认为是运行js阶段。但这不是绝对的，比如某个script标签在head标签里，那么解析器会解析该script标签，这个会阻塞dom与cssom构建，也就意味着Domcontentloaded的时间被大幅增加，大多数时候我们的script标签放在body后面，这样就不会阻塞浏览器的对dom tree与cssom的构建，可以使界面更早的出现。</li><li>构建render tree</li><li>layout</li><li>paint<br>示例图：<br><img src="http://oupe487b3.bkt.clouddn.com/3818607849-58c93559cd9fc_articlex.png" alt="CRP"></li></ul><p>可以利用Chrome开发者工具下的Timeline去观察整个关键路径渲染的过程，这个具体的timeline分析下次写篇博客中详表。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##线索&lt;/p&gt;
&lt;p&gt;从浏览器地址栏输入一串url到页面呈现这个过程中发生了什么？在很多场合看见过这个问题，但一般也就大概浏览一下，自己并没有去深入研究一番，最近有空便研究了下，网上当然也有很多类似的分析，而且有些甚至涉及到物理层的底层硬件相关，虽然自己本科专业是电子信息专业，但只是懂个轮廓，很多细节还是不太清楚，所以自己的笔记目前就只囊括在非物理层的描述。&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>小程序简易教程-速览</title>
    <link href="http://yoursite.com/2017/12/11/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B-%E9%80%9F%E8%A7%88/"/>
    <id>http://yoursite.com/2017/12/11/小程序简易教程-速览/</id>
    <published>2017-12-11T09:11:21.000Z</published>
    <updated>2018-03-08T13:43:26.146Z</updated>
    
    <content type="html"><![CDATA[<p>##框架<br>在官方demo中，我们用的app()，page()或者直接调用的wx.setStorageSync()等API这些东西都是小程序框架做的事，它的核心是一个数据绑定系统，除了这个数据绑定的主要功能外，还提供页面管理（路由处理，场景注册等），基础组件（scroll-view,navigator,iamge等），丰富的API（wx.setSrorageSync,wx.getUserInfo）等功能。<br><a id="more"></a></p><p>##文件结构</p><p>每个小程序的页面都是由四个文件构成<br>文档结构|样式|脚本|配置<br>-|-|-|-<br>.wxml|.wxss|.js|.json</p><ul><li>.wxml文件，微信标记语言？哈哈，反正主要作用就是表示文档结构的相当于html文件。</li><li>.wxss文件，相当于css文件，用来处理样式表现的，值得注意的一点是引入了rpx这个满足自适应的单位。</li><li>.json文件，是小程序的配置文件，包括对页面的声明注册，一些窗体样式的设置，网络延时设定及tabBar的设置。</li><li>.js文件，主要用来监听并处理小程序的生命周期及声明全局变量，还可以调用框架提供的API如同步存储及同步读取本地数据。除根目录下的app.js文件外，各个page下的js文件都有个page()方法用于注册一个页面，该方法参数是一个对象，通常有data、onShow、onHide等key值。<br>而根目录下的app.json，app.wxss，app.js会被子页面对应的文件的覆盖。</li></ul><p>##逻辑层</p><p>小程序开发的逻辑层是由javascript编写的，但宿主环境并不是浏览器，所以一些BOM的接口或者对象是没有的，比如window,document等。前文说到小程序框架中的主要功能是提供数据传输与事件系统，这个主要就是针对视图层（view）与逻辑层二者。逻辑层映射到文件结构中即是.js的文件，视图层则映射为.wxml的文件。上线时所写的代码最终会被全部打包成一个javascript的文件，估计也使用了webpack般的打包工具。下面介绍逻辑层中的几个重要概念。</p><ul><li>注册程序</li><li>场景值</li><li>注册页面</li><li>路由</li><li>模块化</li><li>API</li><li>注册程序</li></ul><p>App()方法用来注册小程序，只能注册一次且必须在app.js中。参数是一个对象，该对象有四个控制生命周期函数，分别是onLaunch,onShow,onHide,onError。onLaunch是小程序初始化完成时才触发的，全局只触发一次，onShow与onHide方法分别在前后台切换时触发。其中，当用户点击左上角的关闭按钮或者按下home键，小程序并没有销毁而是进入了后台。只有小程序进入后台一定时间或者系统占用资源过多时，小程序才会被销毁。在onLaunch、onShow方法中可获得如下参数，path、qurey、scene,referrerInfo等数据。</p><p>##场景值</p><p>场景值表示进入小程序色方式，比如1001代表从微信发现栏的主入口进入，1005表示顶部搜索框结果进入，1011表示通过扫描二维码的方式进入的。这个值可以在onLaunch或者onShow中通过options获得。<br>注册页面<br>注册一个页面由Page()函数实现，接收一个Object参数，可指定初始数据，生命周期函数与事件处理函数等。一般写在每个页面的page.js中，默认的初始页面可写在page根目录下的index.js中。Object参数说明：<br>属性|类型|描述<br>-|-|-<br>data|Object|页面的初始数据<br>onLoad|Function|生命周期函数-监听页面加载<br>onReady|Function|生命周期函数-监听页面初次渲染完成<br>onShow|Function|生命周期函数-监听页面显示<br>onHide|Function|生命周期函数-监听页面隐藏<br>onUnload|Function|生命周期函数-监听页面卸载<br>onPullDownRefresh|Function|页面相关事件-监听用户下拉动作<br>onReachBottom|Function|页面相关事件-监听上拉触底动作<br>onPageScroll|Function|页面相关事件-监听页面滚动事件<br>onShareAppMessage|Function|页面相关事件-用户点击右上角转发<br>其中onPullDownRefresh方法需要再.json文件中的对window配置enablePullDownRefresh：true才可使用。<br>onReachBottom可在window中配置具体的触发距离，默认值是50</p><p>##如何初始化数据<br>在view层，用双大括号表征变量，在逻辑层中初始化数据的data对象中再给相应变量赋值。</p><p>##生命周期函数</p><ul><li>onLoad：页面加载，一次生命周期函数中只会调用一次，onHide或者onShow并不会对它有影响，可以在onLoad方法中获取打开当前页面所调用的query参数或者获得用户个人信息资料（getUserInfo）</li><li>onShow：页面显示，小程序进入前台时触发，可触发多次。</li><li>onReady:页面准备就绪，只触发一次，代表页面已准备妥当，可以开始与视图层进行交互，若对页面设置wx.setNavigationBarTitle需在onReady之后，也很好理解，因为这个改版导航栏标题的动作就是属于逻辑层与视图层的交互。</li><li>onHide:页面隐藏，小程序进入后台是触发，具体可以为navigateTo与底部tab切换时。</li><li>onUnload:页面卸载，当redirectTo与navigateBack的时候调用。</li></ul><p>##Page对象<br>page.route:可以获得当前页面的路由。<br>page.setData()：将数据从逻辑层异步发送到视图层，而且同步的改变this.data的值。如果不是有setData()而是直接改变this.data则视图层的数据状态不会改变，而且会造成数据不一致，另外要注意的一点是，setData方法一次只能设置1024KB大小的数据。<br>页面路由<br>小程序中的路由管理有一个很重要的概念就是页面栈，以下是几种路由操作时页面栈产生的对应变化。<br>路由操作|页面栈表现|触发时机<br>-|-|-<br>初始化|新页面入栈|小程序打开的第一个页面<br>打开新页面|新页面入栈|wx.navigateTo或使用组件<br>tab切换|全部页面出栈，只留下新tab的页面|wx.switchTab或使用组件<br>重新启动|全部页面出栈，只留下新的页面|wx.relaunch或使用组件<br>页面重定向|当前页面出栈，重定向的页面入栈|wx.redirectTo或使用组件<br>页面返回|页面不断出栈，直到目标页返回页，新页面入栈|wx.navigateBack或组件</p><p>getCurrentPages()–获取当前页面栈的实例，返回一个数组，第一个数组元素为首页，最后一个是当前页面。<br>navigateTo与redirectTo只能打开非tabBar的页面，tabBar页面的路由操作由switchBar负责。<br>relaunch可以打开任何页面，包括tabBar的页面。<br>调用页面路由带的参数，可以在目标页面的onLoad函数中获取。</p><p>##模块化</p><p>与传统的前端文件作用域不同，在小程序中，全局变量不会跨文件污染。每个.js文件中的变量与其余js文件中的变量相互独立。而在跨文件的全局变量实现上如何实现呢，小程序框架通过在在app实例中的global字段作为全局存储空间，对会被经常引用的js公用代码则可以通过require的方式引入，被require的文件通过module.exports暴露出来。<br>API<br>API的话有一些特征，比如wx.on开头的一般用于监听某个事件发生的，参数多是一个callback函数，而其余的API参数多是一个Object对象，Object中可指定success，fail,compltelai来接收接口调用结果。剩余各个API具体功能的就不细说了，API*小程序过一遍就是，总结下来就是功能还是特别强大的，诸如获取用户信息，多媒体支持，地理位置，设备相关等接口都有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##框架&lt;br&gt;在官方demo中，我们用的app()，page()或者直接调用的wx.setStorageSync()等API这些东西都是小程序框架做的事，它的核心是一个数据绑定系统，除了这个数据绑定的主要功能外，还提供页面管理（路由处理，场景注册等），基础组件（scroll-view,navigator,iamge等），丰富的API（wx.setSrorageSync,wx.getUserInfo）等功能。&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>当前常用html模块emmet自定义</title>
    <link href="http://yoursite.com/2017/10/17/%E5%BD%93%E5%89%8D%E5%B8%B8%E7%94%A8html%E7%BB%93%E6%9E%84emmet%E8%87%AA%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2017/10/17/当前常用html结构emmet自定义/</id>
    <published>2017-10-17T14:18:35.000Z</published>
    <updated>2018-03-08T13:43:32.167Z</updated>
    
    <content type="html"><![CDATA[<p>##工欲善其事必先利其器</p><p>现在前端可以选择的IDE还是很多的，常见的有Atom,webstorm,VS code,Hbuilder等，但对于平时的一些小项目，sublime-text还是我的首选编辑器,单启动快这个优点就很讨人喜欢，加上配套的各种插件，简直是日常工作的好伙伴。本篇简单讲述了目前工作中常用业务模块(pc端基本模板，移动端基本模板，轮播，新闻列表等)的emmet自定义缩写。<br><a id="more"></a></p><p>##sublime text常用插件</p><p>下面是我自己常用的一些插件：</p><ul><li>Alignment——格式对齐</li><li>AutoFileName——文件名自动提示（5星推荐）</li><li>Autoprefixer——css前缀补全</li><li>BracketHighlighter——括号高亮匹配（5星推荐）</li><li>Clipboard Diff——粘贴板与选中区域diff</li><li>ColorPicker——拾色器</li><li>ConvertToUTF8——转utf8文件格式</li><li>CSS Format——css格式化</li><li>Emmet——快速编辑神器,前身是Zen Coding（5星推荐）</li><li>Git——版本控制神器,</li><li>JsForma——js格式化,</li><li>SFTP——快速编辑远程服务器文件（5星推荐）</li><li>SideBarEnhancements——加强侧边栏</li><li>SideBarFolders——文件夹管理</li><li>View In Browser——浏览器快捷打开（5星推荐）<br>以上的插件都支持自定义快捷键，前提是记得不要冲突哦！</li></ul><p>##emmet自定义带你飞</p><p>作为web开发者必备的emmet，前身是著名的zen-coding,可以让我们超快速地编写HTML/CSS/JS，而且更强大的是它还支持用户自定义配置，简直是不能更强大！下面是我对日常中的一些常用html结构的封装。<br>设置过程如下，如果是sublime-text2则首先要找到 snippets.json这个文件，路径是preferences&gt;browse packages，打开其中的emmet文件夹即可找到snippets.json这个文件,如果没有，可能是您没有安装emmet插件，或者您安装了但目录里没有这个文件夹，这时候您需要手动安装，下载地址 <a href="https://github.com/sergeche/emmet-sublime，再把下载的压缩包解压到" target="_blank" rel="noopener">https://github.com/sergeche/emmet-sublime，再把下载的压缩包解压到</a> packages文件夹下。若是sublime-text3则不像sublime text2那样直接找到emmet snippets.json文件，要在st目录的Packages\User 下手动创建emmet目录，并在该目录下创建snippets.json文件，该文件默认定义参考链接： <a href="https://github.com/emmetio/emmet/blob/master/snippets.json" target="_blank" rel="noopener">https://github.com/emmetio/emmet/blob/master/snippets.json</a> 我们只需重写要重新定义的snippets即可。<br>下面是我在snippets.json中自定义的常用html代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">“snippets”: &#123;</span><br><span class="line">&quot;variables&quot;: &#123;</span><br><span class="line">    &quot;news1&quot;:&quot;新闻&quot;,</span><br><span class="line">    &quot;news2&quot;:&quot;公告&quot;,</span><br><span class="line">    &quot;news3&quot;:&quot;攻略&quot;,</span><br><span class="line">    &quot;news4&quot;:&quot;活动&quot;,</span><br><span class="line">    &#125;,</span><br><span class="line">&quot;html&quot;: &#123;</span><br><span class="line">    // https://github.com/emmetio/emmet/blob/master/snippets.json#L644</span><br><span class="line">    &quot;abbreviations&quot;: &#123;</span><br><span class="line">        &quot;doc0&quot;: &quot;html&gt;(head&gt;meta[charset=&apos;utf-8&apos;]+title&#123;$&#123;1:&#125;&#125;+m:co+m:re+m:au+m:ke+m:de+l:in)+body&gt;j:jq+j:sw+j:in&quot;,</span><br><span class="line">        &quot;doc1&quot;: &quot;html&gt;(head&gt;meta[charset=&apos;utf-8&apos;]+title&#123;$&#123;1:&#125;&#125;+m:vp+m:au+m:ke+m:de+m:ph+l:in)+body&gt;j:jq+j:sw+j:in&quot;,</span><br><span class="line">        &quot;co&quot;: &quot;!!!+doc0[lang=&apos;zh-Hans&apos;]&quot;,</span><br><span class="line">        &quot;mo&quot;: &quot;!!!+doc1[lang=&apos;zh-Hans&apos;]&quot;,</span><br><span class="line">        &quot;m:vp&quot;: &quot;&lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\&quot; /&gt;&quot;,</span><br><span class="line">        &quot;m:co&quot;: &quot;&lt;meta http-equiv=\&quot;X-UA-Compatible\&quot; content=\&quot;IE=edge,chrome=1\&quot; /&gt;&quot;,</span><br><span class="line">        &quot;m:re&quot;: &quot;&lt;meta name=\&quot;renderer\&quot; content=\&quot;webkit\&quot; /&gt;&quot;,</span><br><span class="line">        &quot;m:au&quot;: &quot;&lt;meta name=\&quot;author\&quot; content=\&quot;2017@Phil\&quot; /&gt;&quot;,</span><br><span class="line">        &quot;m:ke&quot;: &quot;&lt;meta name=\&quot;keywords\&quot; content=\&quot;\&quot; /&gt;&quot;,</span><br><span class="line">        &quot;m:de&quot;: &quot;&lt;meta name=\&quot;description\&quot; content=\&quot;\&quot; /&gt;&quot;,</span><br><span class="line">        &quot;m:ph&quot;: &quot;&lt;meta name=\&quot;format-detection\&quot; content=\&quot;telephone=no\&quot;/&gt;&quot;,</span><br><span class="line">        // css</span><br><span class="line">        &quot;l:in&quot;: &quot;link[href=css/index.css]&quot;,</span><br><span class="line">        // js</span><br><span class="line">        &quot;j:jq&quot;: &quot;script[src=js/jquery-1.9.1.min.js]&quot;,</span><br><span class="line">        &quot;j:sw&quot;: &quot;script[src=js/swiper.3.1.2.min.js]&quot;,</span><br><span class="line">        &quot;j:in&quot;: &quot;script[src=js/index.js]&quot;,</span><br><span class="line">        // &quot;swiper&quot;</span><br><span class="line">        &quot;sw5&quot;:&quot;.swiper-container&gt;.swiper-wrapper&gt;(.swiper-slide&gt;img[src=img/banner$@0.jpg alt=轮播图$@1])*5+.swiper-pagination&quot;,</span><br><span class="line">        &quot;sw3&quot;:&quot;.swiper-container&gt;.swiper-wrapper&gt;(.swiper-slide&gt;img[src=img/banner$@0.jpg alt=轮播图$@1])*3+.swiper-pagination&quot;,</span><br><span class="line">        // &quot;newslist&quot;</span><br><span class="line">        &quot;uld&quot;:&quot;ul.ul-download&gt;(li&gt;a[href=javascript:void(0)])*2&quot;,</span><br><span class="line">        &quot;newslist&quot;:&quot;.news-wrap&gt;ul.news-nav&gt;(li&gt;a.bor-b[href=javascript:void(0)]&#123;最新&#125;+em)+(li&gt;a[href=javascript:void(0)]&#123;$&#123;news$@1&#125;&#125;+em)*4+(li.lilast&gt;a#more[href=javascript:void(0)]&#123;+&#125;+em)^.newslist&gt;(ul&gt;(li&gt;a[href=javascript:void(0)]&gt;span.title&#123;[新闻]&#125;+p&#123;黑桃的新闻占位符123456789&#125;+span&#123;[11/11]&#125;)*6)+(ul.hide&gt;(li&gt;a[href=javascript:void(0)]&gt;span.title&#123;[新闻]&#125;+p&#123;黑桃的新闻占位符123456789&#125;+span&#123;[11/11]&#125;)*5)*4&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>emmet的自定义代码的语法极为简单，有全局变量定义，预定义占位等功能,配置完以后，</strong></p><ul><li>输入co则会快速的生成一个pc端项目的html结构。</li><li>输入mo则会快速的生成一个pc端项目的html结构。</li><li>输入sw5则会快速的生成一个含5个banner的swiper轮播器。</li><li>输入newslist则会快速生成新闻模块。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##工欲善其事必先利其器&lt;/p&gt;
&lt;p&gt;现在前端可以选择的IDE还是很多的，常见的有Atom,webstorm,VS code,Hbuilder等，但对于平时的一些小项目，sublime-text还是我的首选编辑器,单启动快这个优点就很讨人喜欢，加上配套的各种插件，简直是日常工作的好伙伴。本篇简单讲述了目前工作中常用业务模块(pc端基本模板，移动端基本模板，轮播，新闻列表等)的emmet自定义缩写。&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="效率" scheme="http://yoursite.com/tags/%E6%95%88%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>什么是BFC？</title>
    <link href="http://yoursite.com/2017/08/11/%E4%BB%80%E4%B9%88%E6%98%AFBFC%EF%BC%9F/"/>
    <id>http://yoursite.com/2017/08/11/什么是BFC？/</id>
    <published>2017-08-11T11:57:13.000Z</published>
    <updated>2018-03-08T13:56:30.397Z</updated>
    
    <content type="html"><![CDATA[<p>##什么是BFC?</p><p>BFC：详细叙述BFC这个概念时，先要了解box与formatting context,不同的box会形成不同的Formatting context,box类型分为以下三种，</p><ul><li>block-level elements，比如display:block/list-item/table</li><li>inline-level elements，比如display:inline-block/inline/inline-table</li><li>run-in elements，css3中新出的规范，大意是根据上下文来决定自身的。比如display.display:flex<br>而在css2.1中Formatting context又分为两种（css3中又加入了FFC,GFC），一种是block-formatting-context(BFC)<a id="more"></a></li></ul><p>另一种是inline-formatting-context(IFC)，所谓的formatting-context的作用是指它代表了一种渲染规则，它决定了其子元素如何定位，以及其与其他元素的关系和相互作用。具体而言，比如BFC，它的规则是这样的：</p><ul><li>BFC中的box会从containing block顶部开始在垂直方向上一个个的放置。</li><li>box垂直方向上的距离由margin决定，属于同一个BFC的相邻box在垂直方向上的margin会发生重叠（margin-collapse，具体表现为比如上一个的margin-bottom会与相邻的下一个box的margin-top重叠（那二者间的margin值会取大的那个值）,还有种情况是1个block-box内嵌套着一个子block-box(inline-box是没有margin-top这个css属性的，此时要满足它们之间没有存在padding,border即content-box是重叠的时候)的情况时也会出现margin-collapse,比如给子block-box设置margin-top则父block-box也会共用这margin-top.</li><li>在bfc布局中，每个盒子外侧紧挨着containing block的左边缘，就算它是个浮动元素。</li><li>具有BFC特性的父元素在计算高度时会将浮动的子元素包括在内。</li><li>BFC是页面元素里独立存在的作用块，它不影响外面的布局，外面的元素也不会影响到BFC里面的布局。</li></ul><p>##哪些情况下会触发BFC？</p><ul><li>根元素以及包含它的元素，比如body，html,viewport。</li><li>position:absolute/fixed的元素，还有float不为none的值。</li><li>overflow值不为visible。</li><li>display:为inline-blcok,table-caption,table-cell.flex</li></ul><p>##那了解BFC以后有什么意义呢？</p><ul><li>可以理解浏览器渲染过程的一些规则。</li><li>可以清除浮动带来的布局影响。</li><li>可以合理避免margin-collapse</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##什么是BFC?&lt;/p&gt;
&lt;p&gt;BFC：详细叙述BFC这个概念时，先要了解box与formatting context,不同的box会形成不同的Formatting context,box类型分为以下三种，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;block-level elements，比如display:block/list-item/table&lt;/li&gt;
&lt;li&gt;inline-level elements，比如display:inline-block/inline/inline-table&lt;/li&gt;
&lt;li&gt;run-in elements，css3中新出的规范，大意是根据上下文来决定自身的。比如display.display:flex&lt;br&gt;而在css2.1中Formatting context又分为两种（css3中又加入了FFC,GFC），一种是block-formatting-context(BFC)
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>flex基本用法</title>
    <link href="http://yoursite.com/2017/07/06/flex%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2017/07/06/flex基本用法/</id>
    <published>2017-07-06T14:25:32.000Z</published>
    <updated>2018-03-08T13:56:41.193Z</updated>
    
    <content type="html"><![CDATA[<p>仿芒果TV小程序中出现的flex布局的<strong>align-items</strong>属性,正好复习下<strong>flex布局</strong><br><a id="more"></a></p><p>##如何使用flex</p><p>在父元素添加flex属性，写法如下：  </p><blockquote><p>display:-webkit-box;<br>display:-webkit-flex;<br>display:flex;</p></blockquote><p>想让子元素自适应，可添加以下代码：</p><blockquote><p>-webkit-box-flex:1;<br>-webkit-flex:1;<br>-flex:1;</p></blockquote><p>##子元素在垂直方向的排列布局</p><p>兼容性写法：</p><blockquote><p>-webkit-box-align：<br> -webkit-align-items：<br> align-items：</p></blockquote><p>属性值:<br>顶部|居中|基线|底部|拉伸<br>-|-|-|-|-<br>flex-start|center|baseline|flex-end|stretch<br><em>2009版本的box写法中，flex-start,flex-end改为start,end.</em></p><p>##子元素在水平方向的排列布局</p><p>兼容性写法： </p><blockquote><p>-webkit-box-pack：<br>-webkit-justify-content：<br>justify-content:</p></blockquote><p>属性值：<br>顶部|居中|底部|靠边居中|完全居中<br>-|-|-|-|-<br>flex-start|center|flex-end|space-between|space-around<br><em>2009版本的box写法中，flex-start,flex-end改为start,end且space-between与space-around均改为justify</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;仿芒果TV小程序中出现的flex布局的&lt;strong&gt;align-items&lt;/strong&gt;属性,正好复习下&lt;strong&gt;flex布局&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>nodejs概览</title>
    <link href="http://yoursite.com/2017/06/12/nodejs%E6%A6%82%E8%A7%88/"/>
    <id>http://yoursite.com/2017/06/12/nodejs概览/</id>
    <published>2017-06-12T15:05:22.000Z</published>
    <updated>2018-03-08T14:04:36.750Z</updated>
    
    <content type="html"><![CDATA[<p>##nodejs特点</p><p>node.js 特点是异步式I/O，I/O是指涉及磁盘读写，网络通信、数据库读写等任何涉及计算机存储结构的输入输出等操作。适用情景是处理高并发、轻计算的业务情景，比如网络聊天，因为它是单线程的处理过程，系统的计算能力有限，我猜可能是因为cpu把很多资源配置在了事件驱动的这个机制中来实现异步I/O。以后可以考虑用goLang来处理这种复杂计算网络业务。<br> <a id="more"></a></p><p>##node.js的回调函数与事件:</p><p>初步涉及到文件读取模块（fs）与事件模块(events),文件读取模块又分为异步与同步（sync),异步的readFile()有三个参数，文件路径,文件格式，回调函数，其中回调函数有2个默认参数，第一个是抛出的异常err,另一个是返回的数据结果data。同步的readFile（）没有第三个参数即回调函数，函数执行后返回读取的数据结果。事件模块涉及到获取事件对象，注册事件，触发事件。获取事件发射器对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter=<span class="built_in">require</span>(<span class="string">'events'</span>).EventEmitter；</span><br></pre></td></tr></table></figure></p><p>tips:1.require events not event,get EventEmitter instead of eventEmitter and it’s a property.<br>2.when create a object ,the first letter of variable is supposed to uppercase.<br>3.eventObject.on(eventName,callback)<br>4.to trigger event is use event.emit(eventName).</p><p>##模块与文件模块：</p><p>node.js中的模块分为两种，一种是原生模块，包括http,fs，event等，还有一种文件模块，通常就是一个js文件（.js)，或者一些c++/c编译后的一个扩展（.node）,还有json后缀的文件。node会根据不同的后缀名对执行不同的加载机制。关于node编译这些文件模块时，特别是js的文件模块时，它会将模块包裹到一个匿名自执行函数中，这个函数带有require,exports,module等参数，这是我们在某个js文件中可直接调用require的原因。</p><p>Node.js的模块分为两类，一类为原生模块，一类为文件模块。原生模块在Node,js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。其中原生模块都被定义在lib这个目录下面，文件模块则不定性。</p><p>由于通过命令行加载启动的文件几乎都为文件模块。我们从Node.js如何加载文件模块开始谈起，加载文件模块的工作，主要由原生模块module来实现和完成，该原生模块在启动时已经被加载，进程直接调用到runMain静态方法。<br>CommonJS规范是什么？我们知道像java有引入类或者包这样的依赖机制，像c或c++也有类似的引入机制，就算在js中也有引入各种工具库如jquery这样的概念，CommonJS就是对于引入这种依赖文件的一种规范、标准，因为js是一门很自由的函数式编程语言，没有相关规范的话，在工程中的榫接是会有问题的，不利于工程化。Node.js是这种规范的实现，包括它当中的原生模块机制或者文件模块格式等都是遵循CommonJS标准的，CommonJS规范里具体包括以下内容：</p><p>1.Modules</p><p>2.Binary strings and buffers</p><p>3.Charset encoding</p><p>4.Binary,buffered,and textual input and output(io) streams</p><p>5.System process argument,environment,and streams</p><p>6.File System interface</p><p>7.Socket streams</p><p>8.Unit test assertions,running,and reporting</p><p>9.Web server gateway interface,JSGI</p><p>10.Local and remote packages and package management</p><p>CommonJS在浏览器中不能直接应用，一般需要用browserify来打包使浏览器拥有相关能力，相当于个变量引入的配置问题。像实现了CommonJS的node.js为什么会更适用于服务器端，是因为多数时候我们的文件都是在本地的，而在浏览器中我们是要通过http等请求从服务器端拉取文件的。而AMD是require.js在其发展过程中推广的一种非服务器端的规范，它使人们在浏览器中也能良好的运用js的包依赖机制，一开始它倾向于前置依赖，即事先把所有依赖先写出来。CMD是sea.js在其发展中推广的另一张规范，它特点是就近依赖。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##nodejs特点&lt;/p&gt;
&lt;p&gt;node.js 特点是异步式I/O，I/O是指涉及磁盘读写，网络通信、数据库读写等任何涉及计算机存储结构的输入输出等操作。适用情景是处理高并发、轻计算的业务情景，比如网络聊天，因为它是单线程的处理过程，系统的计算能力有限，我猜可能是因为cpu把很多资源配置在了事件驱动的这个机制中来实现异步I/O。以后可以考虑用goLang来处理这种复杂计算网络业务。&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化初识</title>
    <link href="http://yoursite.com/2017/06/12/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2017/06/12/前端工程化初识/</id>
    <published>2017-06-12T12:37:15.000Z</published>
    <updated>2018-03-08T12:36:57.799Z</updated>
    
    <content type="html"><![CDATA[<p>##前端模块化<br>传统的前端项目构造一般只需要几个html文件,css文件加上少量的js文件，整个项目的组织关系清晰简单，js文件的相互依赖关系也不复杂。但2010年后，前端越来越往web app方向发展，一个工程或者项目有很多的js文件，相互间的依赖也较复杂，浏览器中可能需要实现更多的功能，需要全页面刷新的情况也较少。这个时候，对于如何组织项目的文件结构，如何处理js文件的相互依赖，减少请求，如何在保持效率、性能的情况下完成项目需求，都推动着前端模块化的发展。<br><a id="more"></a><br>非模块化的传统前端构造中，js文件的组织结构就是增加script标签或js文件，但是对于单个js文件如何暴露接口以及因此造成的变量名冲突，各js文件间的相互依赖，还有诸如按需加载等性能的优化会存在大量问题。遵循一定规范的模块化工程则具有无需过多考虑变量污染且依赖关系清晰可靠，代码执行效率高的优点。</p><p>##主流的规范</p><p>说到前端工程化，就不得不提前端模块化规范。目前主流的模块化规范为以下四种：</p><ul><li>AMD 异步加载，异步执行，不存在阻塞，require.js遵循此规范</li><li>CMD 异步加载，同步执行，sea.js遵循次规范</li><li>CommonJS 同步加载，同步执行，nodejs、browserify.js遵循此规范</li><li>ES6 异步加载，同步执行，ES2015的实践规范(最新的javascript语言标准）。<br>关于加载与执行的区别：加载只是个下载文件过程，执行是代码执行阶段。<br>一般script中的js文件都是下载完即刻执行，虽然现代浏览器中的js文件是并行下载，但是其执行时间的存在肯定也会影响后续DOM结构的渲染，所有如果script标签后有DOM的渲染内容，可以考虑给该script标签添加defer属性，来延迟执行，这样就不会影响后续DOM渲染而出现白屏的等待，具体执行时机会在document的DOMContentLoaded之前（defer属性不支持早期的chrome版本）。script标签还有个async属性可以用来延时执行，但是它有个不可靠的地方是它的执行时机是在引用的js文件下载完的时刻，即一下载完就执行，可能这时候其中的依赖文件还未下载完，因为无法预测并行下载的多个js文件哪个先下载完，所以也不推荐在依赖关系复杂的项目中使用。</li></ul><p>##构建工具</p><p>构建工具存在的意义当然是提高前端工程的构建效率，让我们从无意义的重复劳动中解脱出来。下面简要描述了目前流行的几个自动化构建工具：</p><ul><li><p>gulp: 能实现js文件压缩,css文件压缩，sass编译，图片压缩，自动刷新等功能</p></li><li><p>webpack: 模块打包工具，可以编译babel,typescript,同时也具有图片压缩，sass编译等功能</p></li><li><p>browserify: 为浏览器环境使用的模块打包工具，与nodejs一样使用require方式加载</p></li><li><p>grunt: 跟gulp类似作用，都是用于提高工作效率的</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##前端模块化&lt;br&gt;传统的前端项目构造一般只需要几个html文件,css文件加上少量的js文件，整个项目的组织关系清晰简单，js文件的相互依赖关系也不复杂。但2010年后，前端越来越往web app方向发展，一个工程或者项目有很多的js文件，相互间的依赖也较复杂，浏览器中可能需要实现更多的功能，需要全页面刷新的情况也较少。这个时候，对于如何组织项目的文件结构，如何处理js文件的相互依赖，减少请求，如何在保持效率、性能的情况下完成项目需求，都推动着前端模块化的发展。&lt;br&gt;
    
    </summary>
    
      <category term="FED" scheme="http://yoursite.com/categories/FED/"/>
    
    
      <category term="前端工程化" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
</feed>
